From ivan.miljenovic at gmail.com  Wed Dec 14 07:40:20 2011
From: ivan.miljenovic at gmail.com (Ivan Lazar Miljenovic)
Date: Wed, 14 Dec 2011 17:40:20 +1100
Subject: [Haskell-cafe] Splitting off many/some from Alternative
In-Reply-To: <84E2499A-1794-4A54-9CA8-446FA3571E13@gmail.com>
References: <1FA8D361-5F28-4FE4-AAE8-1761B98E6381@gmail.com>
	<CACw0niK9Bv6q3UxMk8XHtb_=6KsrHTn-4mkjhDDEUX_LdmAqYQ@mail.gmail.com>
	<CAECnf4DtEDnf4Z+Z7MKZ731f+c6t+ZGLDPkTDWt36MSsqXLm4g@mail.gmail.com>
	<CACw0ni+xEokzO6K7gkGT=SwaggGqG-HkNq+bsyqvj4ZQFaKhwg@mail.gmail.com>
	<CAECnf4ApS=L-YmMLUTCpB7b+kqv3Dps15irucqrngybxau_iAQ@mail.gmail.com>
	<CACw0niKAp9HWV3qxBm6bN5Z2Z9yUVeTw9H9S9DERH9ofrWaXKQ@mail.gmail.com>
	<84E2499A-1794-4A54-9CA8-446FA3571E13@gmail.com>
Message-ID: <CA+u6gbzmc6hk-Cr-pkNOok0SzOBm+sOK+kycSkxfRJRUCW4FoA@mail.gmail.com>

On 14 December 2011 17:08, Gregory Crosswhite <gcrosswhite at gmail.com> wrote:
>
> On Dec 13, 2011, at 5:09 AM, Bryan O'Sullivan wrote:
>
> Correct. And your example of "some (Just 1)" inflooping was not a
> counterargument, but rather an illustration that perhaps some people (and
> I'm not trying to imply you here, don't worry) don't understand what some
> and many are supposed to do.
>
>
> But if you can't determine whether you can use certain methods of a
> typeclass without first knowing more about what type you are working with,
> then that breaks the abstraction since you can no longer treat a typeclass
> as a promise that given set of methods can be applied to a type.

Doesn't this already apply to much of "Monadic" code?  Apart from some
basic combinators in Control.Monad or the definitions of monad
transformers, how much of what you write in do-blocks is applicable to
some generic Monad instance as opposed to a specific Monad?

-- 
Ivan Lazar Miljenovic
Ivan.Miljenovic at gmail.com
IvanMiljenovic.wordpress.com


